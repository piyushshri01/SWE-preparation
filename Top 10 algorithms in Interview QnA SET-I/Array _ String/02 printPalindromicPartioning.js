function isPalindrome(string,low, high){
    while (low < high){
        if (string[low] != string[high]){
            return false
        } 
        low += 1
        high -= 1        
    } 
    return true
} 


function allPalPartUtil(allPart, currPart,start, n, string){ // ([], [], 0, 6, nititn)
    if (start >= n){
        x = currPart; 
        allPart.push(...x) //(nititn)
        return
    } 

    // Pick all possible ending points for substrings 
    for(let i = start; i < n; i++){
        // If substring str[start..i] is palindrome 
        if (isPalindrome(string, start, i)){
            // Add the substring to result 
            currPart.push(string.substring(start, i+1)) // [n,i,t,i,t,n]

            // Recur for remaining remaining substring 
            allPalPartUtil(allPart, currPart,   // ([], [n,i,t,i,t,n], 6, 6, nititn)
                        i + 1, n, string) 

            // Remove substring str[start..i]  
            // from current partition 
            currPart.pop() 
        }         
    } 
}
        

// Function to print all possible  
// palindromic partitions of str.  
// It mainly creates vectors and  
// calls allPalPartUtil() 
function allPalPartitions(string) {
    n = string.length // 6

    // To Store all palindromic partitions 
    let allPart = [] 

    // To store current palindromic partition 
    let currPart = [] 

    // Call recursive function to generate  
    // all partitions and store in allPart 
    allPalPartUtil(allPart, currPart, 0, n, string) // ([], [], 0, 6, nititn)

    // Print all partitions generated by above call 
    for(let i = 0; i < allPart.length; i++){
        for (let j = 0; j < allPart[i].length; j++){
            // console.log(allPart[i][j], end = " ") 
            console.log(allPart[i][j]) 
            // newArr.push(allPart[i][j])
        }
    console.log();
    } 
     
}



let string = "nititn"
allPalPartitions(string)